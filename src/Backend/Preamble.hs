{-
    EEL -- Extensible Experimental Language
    by Lukáš Kuklínek, 2013
-}


module Backend.Preamble(
        -- * Preamble generation
        preamble,
    ) where

import qualified Text.PrettyPrint as P
import Text.PrettyPrint((<+>))

import Backend.CodeGen
import Backend.Runtime

import Paths_eel as EEL
import Data.Version

-- | Generate the preamble
preamble mainName = do
    appendRaw $ P.semi <+> P.text "generated by EEL compiler version" <+> P.text (showVersion EEL.version)
    blankLine
    appendRaw $ P.semi <+> P.text "type definitions"
    appendRaw $ fill "%eelstack = type #" [llStackDef]
    appendRaw $ fill "%eellist  = type #" [llListDef]
    appendRaw $ fill "%eelqot   = type #" [llQotDef]
    blankLine
    appendRaw $ P.semi <+> P.text "external declarations"
    funcPrototype llRaw "@GC_malloc" [llSize]
    mapM_ (\nme -> funcPrototype llFloat ("@llvm." ++ nme ++ ".f" ++ show ptrBits) [llFloat]) ["sin", "log"]
    funcPrototype llFloat ("@llvm.pow.f" ++ show ptrBits) [llFloat, llFloat]
    funcPrototype llIntNative "@fgetc" [llRaw]
    funcPrototype llIntNative "@fputc" [llIntNative, llRaw]
    appendRaw $ P.text "@stdin = external global i8*"
    appendRaw $ P.text "@stdout = external global i8*"
    blankLine
    -- Main function
    printMain mainName
    blankLine
    -- C string to EEL string
    printC2S
    blankLine
    -- EEL quotation runners
    printEelRunners
    blankLine

-- | C string to EEL string conversion
printC2S = do
    -- C string to EEL string
    [strin, nextstr] <- fresh llRaw ["strin", "nextstr"]
    [lptrnext] <- fresh (llPtr llList) ["lptrnext"]
    appendRaw $ P.text "; C string to EEL string conversion"
    appendRaw $ funcHeader llList "@eelC2S" [strin] <+> P.lbrace
    label "start"
    list <- instr (llPtr llList) "list" "alloca #" [llList]
    store (LLVar llList "null") list
    branch "loop"
    label "loop"
    str <- phi llRaw "str" [(strin, "start"), (nextstr, "body")]
    lptr <- phi (llPtr llList) "lptr" [(list, "start"), (lptrnext, "body")]
    chr <- load llChar "chr" str
    cmp <- instr llBool "cmp" "icmp eq #, 0" [chr]
    branchCond cmp "end" "body"
    label "body"
    appendTmpl "# = getelementptr #, i32 1" [P.text (llVarName nextstr), llVarDoc str]
    newElem <- alloc (llPtr llListDef) "elem" (2 * ptrBytes)
    newElemR <- bitcast llList "elemR" newElem
    store newElemR lptr
    appendTmpl "# = getelementptr #, i32 0, i32 1" [P.text (llVarName lptrnext), llVarDoc newElem]
    store (LLVar llList "null") lptrnext
    gepFst (llPtr llRaw) "charpr" newElem >>= bitcast llRaw "charp" >>= store chr
    branch "loop"
    label "end"
    load llList "ret" list >>= ret
    appendRaw $ P.rbrace

-- | EEL runners
printEelRunners = do
    appendRaw $ P.text "; Composition quotation runner"
    printOneEelRunner "comp" $ \fr gr -> do
        f <- bitcast llQot "f" fr
        g <- bitcast llQot "g" gr
        runQot f >> runQot g
    blankLine
    appendRaw $ P.text "; Constant data quotation runner"
    printOneEelRunner "data" $ \fr _gr -> do
        push fr
    blankLine
    appendRaw $ P.text "; Single function runner"
    printOneEelRunner "func" $ \fr _gr -> do
        fun <- bitcast llStackFunc "fun" fr
        getStack >>= callRaw llStack "stk" (llVarName fun) . return >>= setStack
    blankLine
    appendRaw $ P.text "; Fixed point runner"
    printOneEelRunner "fixp" $ \fr _gr -> do
        qot <- bitcast llQot "qot" fr
        mkQotFixp qot >>= push
        runQot qot

printOneEelRunner name body = do
    [fr, gr] <- fresh llRaw ["fr", "gr"]
    stk <- fresh1 llStack "stk"
    appendRaw $ funcHeader llStack ("@eelrun." ++ name) [stk, fr, gr] <+> P.lbrace
    setStack stk
    () <- body fr gr
    stk' <- getStack
    ret stk'
    appendRaw $ P.rbrace

-- | Main function wrapper: stack initialisation and argument passing
printMain Nothing = comment "No main function" ([] :: [Int])
printMain (Just mainName) = do
    let argvTy = llPtr (llPtr llChar)
    argc <- fresh1 llIntNative "argc"
    [argv, argvPNext] <- fresh argvTy ["argv", "argvPNext"]
    [arglPNext] <- fresh (llPtr llList) ["arglPNext"]
    -- function header
    appendRaw . P.text $ "; main function is " ++ show mainName
    appendRaw $ funcHeader llIntNative "@main" [argc, argv] <+> P.lbrace
    -- initialise
    label "start"
    argl <- instr (llPtr llList) "argl" "alloca #" [llList]
    store (LLVar llList "null") argl
    branch "loop"
    -- loop condition
    label "loop"
    argvP <- phi argvTy "argvP" [(argvPNext, "body"), (argv, "start")]
    arglP <- phi (llPtr llList) "arglP" [(arglPNext, "body"), (argl, "start")]
    arg <- load llRaw "arg" argvP
    cmp <- instr llBool "cmp" "icmp eq #, null"  [arg]
    branchCond cmp "main" "body"
    -- loop body
    label "body"
    appendTmpl "# = getelementptr #, i32 1" [P.text (llVarName argvPNext), llVarDoc argvP]
    argR <- load llRaw "argR" argvP
    argS <- callRaw llList "argS" "@eelC2S" [argR]
    argE <- alloc llList "argE" (2*ptrBytes)
    store argE arglP
    appendTmpl "# = getelementptr #, i32 0, i32 1" [P.text (llVarName arglPNext), llVarDoc argE]
    store (LLVar llList "null") arglPNext
    gepFst (llPtr llRaw) "argDR" argE >>= bitcast (llPtr llList) "argD" >>= store argS
    branch "loop"
    -- main
    label "main"
    comment "initialise the stack" ([] :: [Int])
    setStack (LLVar llStack "null")
    args <- load llList "args" argl
    push args
    comment "Invoke main #" [mainName]
    initStk <- getStack
    finalStk <- callRaw llStack "stk" mainName [initStk]
    comment "Convert final stack to return value" ([] :: [Int])
    finalStkS <- bitcast (llPtr llStackDef) "stkS" finalStk
    retvalI <- gepSnd (llPtr llRaw) "retRP" finalStkS >>= bitcast (llPtr llInt) "retP" >>= load llInt "ret"
    retval <- if intBits < ptrBits
                then instr llIntNative "ret" "trunc # to #" [llVarDoc retvalI, llTypeDoc llIntNative]
                else return retvalI
    comment "return exit code" ([] :: [Int])
    ret retval
    appendRaw $ P.rbrace
