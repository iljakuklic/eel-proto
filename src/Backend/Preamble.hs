

module Backend.Preamble(llStack, llStackDef, llStackPtr, llListDef, preamble, alloc) where

import qualified Text.PrettyPrint as P
import Text.PrettyPrint((<+>))

import Backend.CodeGen

-- | Stack LLVM type
llStack = llPtr (llNamed "%eelstack")
-- | LLVM stack type definition
llStackDef = llStruct [llStack, llRaw]
-- | Pointer to an one-level-unwrapped stack
llStackPtr = llPtr llStackDef
-- | List LLVM type
llList = llPtr (llNamed "%eellist")
-- | List LLVM type definition
llListDef = llStruct [llList, llRaw]

-- | Generate the preamble
preamble mainName = do
    appendRaw $ P.semi <+> P.text "generated by EEL compiler"
    blankLine
    appendRaw $ P.semi <+> P.text "type definitions"
    appendRaw $ fill "%eelstack = type #" [llStackDef]
    appendRaw $ fill "%eellist = type #" [llListDef]
    blankLine
    appendRaw $ P.semi <+> P.text "external functions"
    funcPrototype llRaw "@GC_malloc" [llSize]
    maybe (return ()) (\m -> funcPrototype llStack m [llStack]) mainName
    blankLine
    -- C string to EEL string
    printC2S
    blankLine
    -- Main function
    printMain mainName
    blankLine
    return ()

printC2S = do
    -- C string to EEL string
    [strin, nextstr] <- fresh llRaw ["strin", "nextstr"]
    [lptrnext] <- fresh (llPtr llList) ["lptrnext"]
    appendRaw $ funcHeader llList "@eelC2S" [strin] <+> P.lbrace
    label "start"
    list <- instr (llPtr llList) "list" "alloca #" [llList]
    store (LLVar llList "null") list
    branch "loop"
    label "loop"
    str <- phi llRaw "str" [(strin, "start"), (nextstr, "body")]
    lptr <- phi (llPtr llList) "lptr" [(list, "start"), (lptrnext, "body")]
    chr <- load llChar "chr" str
    cmp <- instr llBool "cmp" "icmp eq #, 0" [chr]
    branchCond cmp "end" "body"
    label "body"
    appendTmpl "# = getelementptr #, i32 1" [P.text (llVarName nextstr), llVarDoc str]
    tmp <- bitcast (llPtr llListDef) "tmp" lptr
    newElem <- alloc (llPtr llListDef) "elem" (2 * ptrBytes)
    appendTmpl "# = getelementptr #, i32 0, i32 0" [P.text (llVarName lptrnext), llVarDoc newElem]
    store (LLVar llList "null") lptrnext
    gepSnd (llPtr llRaw) "charpr" newElem >>= bitcast llRaw "charp" >>= store chr
    branch "loop"
    label "end"
    load llList "ret" list >>= ret
    appendRaw $ P.rbrace

printMain Nothing = comment "No main function" ([] :: [Int])
printMain (Just mainName) = do
    argc <- fresh1 llIntNative "argc"
    argv <- fresh1 (llPtr . llPtr $ llChar) "argv"
    appendRaw . P.text $ "; main function is " ++ show mainName
    appendRaw $ funcHeader llIntNative "@main" [argc, argv] <+> P.lbrace
    --label "start"
    --label "loop"
    --label "body"
    label "main"
    --args     <- fresh1 llList "args"
    let args = LLVar llList "null"
    comment "initialise the stack" ([] :: [Int])
    initStk  <- alloc llStack "initStk" (2*ptrBytes)
    initStkS <- bitcast (llPtr llStackDef) "initStkS" initStk
    initStkNextP <- gepFst (llPtr llStack) "initStkNextP" initStkS
    store (LLVar llStack "null") initStkNextP
    initStkDataP <- gepSnd (llPtr llRaw) "initStackDataP" initStkS
    argsPtr <- bitcast llRaw "argsPtr" args
    store argsPtr initStkDataP
    comment "Invoke main" ([] :: [Int])
    finalStk <- callRaw llStack "finalStk" mainName [initStk]
    comment "Convert final stack to return value" ([] :: [Int])
    finalStkS <- bitcast (llPtr llStackDef) "finalStkS" finalStk
    retvalRP <- gepSnd (llPtr llRaw) "retvalRP" finalStkS
    retvalP  <- bitcast (llPtr llInt) "retvalP" retvalRP
    retvalI  <- load llInt "retval" retvalP
    retval <- if intBits < ptrBits
                then instr llIntNative "retval" "trunc # to #" [llVarDoc retvalI, llTypeDoc llIntNative]
                else return retvalI
    comment "return exit code" ([] :: [Int])
    ret retval
    appendRaw $ P.rbrace

-- | Allocate a piece of memory for given type
alloc ty nme size = do
    ptr <- callRaw llRaw "ptr" "@GC_malloc" [llVarSize size]
    bitcast ty nme ptr
