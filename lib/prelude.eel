
// COMBINATORS and STACK MANIPULATORS

// swap two top positions
[ qot dip ] 'swap' def
// swap 2nd and 3rd items on the stack
[ [ swap ] dip ] 'swapd' def
// duplicate 2 items
[ [ dup ] dip dup [ swap ] dip ] 'dup2' def
// duplicate 2nd item
[ [ dup ] dip swap ] 'dup2nd' def
// bury top item deep
[ swap swapd ] 'bury' def
[ swap [bury] dip ] 'bury3' def
// dig item to the top
[ swapd swap ] 'dig' def
[ [ dig ] dip swap ] 'dig3' def
// drop 2 top elements
[ zap zap ] 'zap2' def
// apply a function to the stack
[ unit swap dip zap ] 'i' def
// alias for i
[ i ] 'apply' def
// like apply, but keeps the function
[ dup [ i ] dip ] 'keep' def
// dip keeping 2 elements
[ swap [ dip ] dip ] 'dip2' def
// backward composition
[ swap cat ] 'tac' def
// zap in quotation
[ [ zap ] tac ] 'zapq' def
// partial application
[ qot swap cat ] 'papply' def
// swap top two arguments of a quotation
[ [ swap ] tac ] 'flip' def

// UTILITIES

// poor-mans type cast
[ id2 zap ] 'typeas' def
// infinite loop (unifies with anything)
[ [ i ] fix ] 'undefined' def

// UNIT TYPE
// remove unit
[ unit typeas zap ] 'ununit' def
// remove unit in a quotation
[ [ ununit ] tac ] 'ununitq' def

// SUM TYPE

// swap A and B cases in a tagged union
[ [ inb ] [ ina ] sel ] 'abswap' def
// map over A case
[ [ ina ] cat [ inb ] sel ] 'smap' def
// monadic join over sums ((A+B)+B) -> (A+B)
[ [] [ inb ] sel ] 'sjoin' def
// monadic composition of sums (X+B) (X->(Y+B)) -> (Y+B)
[ smap sjoin ] 'sbind' def

// MAYBE

// nothing constructor
[ unit inb ] 'nothing' def
// just constructor
[ ina nothing typeas ] 'just' def
// maybe deconstructor
[ ununitq sel ] 'maybe' def

// BOOLEANS

// true constant
[ unit just ] 'true' def
// false constant
[ nothing true typeas ] 'false' def
// if-then-else
[ [ ununitq ] dip maybe ] 'ifelse' def
// if-then
[ [] ifelse ] 'ifthen' def
// sum type to bool
[ [ zap true ] [ zap false ] sel ] 'sbool' def
// negation
[ [ false ] [ true ] ifelse ] 'not' def
// logical product
[ not [ zap false ] ifthen ] 'and' def
// logical sum
[ [ zap true ] ifthen ] 'or' def

// LISTS

// nil constructor
[ unit inb listw ] 'nil' def
// cons constructor
[ pair ina listw ] 'cons' def
// deconstructor
[ [ [ listu ] dip [ unpair ] tac ] dip maybe ] 'unlist' def
// nil test
[ listu sbool ] 'isnil' def
// left-associative list catamorphism
[ [ flip ] dip swap [ dig3 [ [ bury [ keep ] dip ] dip swap [ bury ] dip i ] [ zap2 ] unlist ] fix ] 'fold' def
// list reversal
[ [ cons ] nil fold ] 'reverse' def
// right-associative list catamorphism
[ [ reverse ] dip2 fold ] 'rfold' def
// list endofunctor
[ qot [dip cons] cat nil rfold ] 'lmap' def
// list concatenation
[ [cons] swap rfold ] 'concat' def
// list filtering
[ qot [ [ dup ] dip ] tac [ dip2 dig [ cons ] [ [ zap ] dip ] ifelse ] cat nil rfold ] 'filter' def
// list generator
[ [ [ keep ] dip dig [ [ i ] dip swap cons ] [ zap2 nil ] maybe ] fix ] 'unfold' def

// special folds
[ [ add ] 0 fold ] 'sum' def
[ [ mul ] 1 fold ] 'product' def
[ [ swap zap 1 add ] 0 fold ] 'length' def
[ lmap [ and ] true fold ] 'all' def
[ lmap [ or ] false fold ] 'any' def

// ORDERING

// A B [A<B case] [A=B case] [A>B case] uncmp
[ swap [ qot [ qot ] dip cat [ ifelse ] cat ] dip maybe ] 'uncmp' def
// compare keeping the operands on the stack
[ dup2 cmp ] 'cmpk' def
[ dup2 fcmp ] 'fcmpk' def
// comparisons
[ [ true  ] [ false ] [ false ] uncmp ] 'lt' def
[ [ false ] [ true  ] [ false ] uncmp ] 'eq' def
[ [ false ] [ false ] [ true  ] uncmp ] 'gt' def
[ [ false ] [ true  ] [ true  ] uncmp ] 'ge' def
[ [ true  ] [ true  ] [ false ] uncmp ] 'le' def
[ [ true  ] [ false ] [ true  ] uncmp ] 'ne' def

// PRODUCT
[ unpair zap ] 'geta' def
[ unpair [ zap ] dip ] 'getb' def
[ unpair swap pair ] 'pswap' def
[ [ unpair ] dip dip pair ] 'pmap' def
// row-like products
[ unit pair ] 'pnil' def
[ geta     ] 'at0' def
[ getb at0 ] 'at1' def
[ getb at1 ] 'at2' def
[ getb at2 ] 'at3' def
[ getb at3 ] 'at4' def

// INTEGERS

// increment
[ 1 add ] 'inc' def
// generate list range
[ [ cmpk le [ dup2nd just [ inc ] dip2 ] [ nothing ] ifelse ] unfold [ zap2 ] dip ] 'range' def
